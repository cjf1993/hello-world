1.单例模式:确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
public class Singleton{
   private static final Singleton singleton = new Singleton();
     private Singleton(){}  //限制多个对象产生
    public static Singleton getInstance(){
           return singleton;   //通过该方法获得实例对象
    }
    //类中其他方法
      public static void doSomething(){}
}

优点：1.内存中只有一个实例，减少内存开销，性能开销。
      2.避免对资源的多重占用
      3.可在系统设置全局访问点，优化和共享资源访问
      
缺点：1. 单例模式一般没有接口，扩展困难；
      2.对测试不利，与单一职责原则冲突。
      
使用场景：要求一个类有且仅有一个对象的。
         要求生成唯一序列号的环境；
         整个项目需要一个共享访问点或共享数据；
         创建一个对象需要消耗的资源过多----IO和数据库等资源；
         需要定义大量的静态常量和方法-----工具类
         
应用：spring的bean默认就是单例         

  2. 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪种类。 
  意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

主要解决：主要解决接口选择的问题。

何时使用：我们明确地计划不同条件下创建不同实例时。

如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

关键代码：创建过程在其子类执行。

应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。
          2、Hibernate 换数据库只需换方言和驱动就可以。

优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 
      2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
      3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，
 在一定程度上增加了系统的复杂度， 同时也增加了系统具体类的依赖。这并不是什么好事。

使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
          2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 
          3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
         有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，
         特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。
         如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
  
    -----------------------------通过传参不同决定返回何种实体类--------------------------------
    
  3.抽象工厂模式：  
意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

主要解决：主要解决接口选择的问题。

何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

如何解决：在一个产品族里面，定义多个产品。

关键代码：在一个工厂里聚合多个同类产品。

应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），
        甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。
        假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），
        在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品）
        ，每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，
        所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品）
        ，裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

注意事项：产品族难扩展，产品等级易扩展。

-----------------------------通过传参不同决定返回何种工厂类--------------------------------



